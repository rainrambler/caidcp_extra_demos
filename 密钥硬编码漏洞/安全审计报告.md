# 安全审计报告
## 项目信息
- 审计对象：密钥硬编码漏洞示例代码 (hardcode_vuln.py)
- 审计日期：2025-08-14
- 审计范围：源代码安全审计
- 报告版本：v1.0

## 漏洞概述

### 1. API密钥硬编码漏洞

**漏洞名称**：敏感凭证硬编码  
**风险等级**：高危  
**CWE编号**：CWE-798: Use of Hard-coded Credentials  
**CVSS评分**：8.8 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N)

**漏洞位置**：
- 文件：hardcode_vuln.py
- 行号：4
- 问题代码：`API_KEY = "sk_live_1a2b3c4d5e6f"`

**漏洞描述**：  
在源代码中直接硬编码了API密钥。这种做法会导致敏感凭证被直接嵌入到代码中，一旦代码被提交到版本控制系统（如Git），即使后续删除，该密钥在历史记录中仍然可见。攻击者可以通过访问代码库获取该密钥，从而获得对API的完全访问权限。

**潜在危害**：
1. 密钥泄露后可能被用于未授权访问API服务
2. 攻击者可能通过API执行敏感操作
3. 可能导致数据泄露、财务损失或服务滥用
4. 即使发现泄露后更改密钥，历史版本中的密钥仍可能被利用

**详细修复建议**：

1. **环境变量方案**
```python
import os

# 从环境变量获取API密钥
API_KEY = os.environ.get("PAY_API_KEY")
if not API_KEY:
    raise ValueError("Missing required PAY_API_KEY environment variable")
```

2. **配置文件方案**
```python
import json
import os
from pathlib import Path

def load_config():
    config_path = Path("config.json")
    if not config_path.exists():
        raise FileNotFoundError("Configuration file not found")
    
    with open(config_path) as f:
        config = json.load(f)
    
    if "api_key" not in config:
        raise ValueError("API key not found in configuration")
    
    return config["api_key"]

API_KEY = load_config()
```

3. **密钥管理服务方案**
```python
from aws_secretsmanager_caching import SecretCache
import boto3

def get_secret():
    secret_cache = SecretCache(
        client=boto3.client('secretsmanager')
    )
    return secret_cache.get_secret_string('my-api-key')

API_KEY = get_secret()
```

**安全加固措施**：
1. 使用环境变量或密钥管理服务存储敏感信息
2. 在CI/CD流程中通过安全的方式注入密钥
3. 实施密钥轮换机制
4. 使用.gitignore忽略包含敏感信息的配置文件
5. 为不同环境（开发、测试、生产）使用不同的密钥
6. 定期审计代码库确保无敏感信息泄露
7. 使用git-secrets等工具在提交前自动检查敏感信息

**修复后效果**：
1. 敏感凭证不再出现在源代码中
2. 密钥可以安全地进行更新和轮换
3. 不同环境可以使用不同的密钥配置
4. 降低了凭证泄露的风险
5. 符合安全最佳实践和合规要求

### 2. API端点硬编码问题

**漏洞名称**：API基础URL硬编码  
**风险等级**：低危  
**CWE编号**：CWE-15: External Control of System or Configuration Setting

**漏洞位置**：
- 文件：hardcode_vuln.py
- 行号：3
- 问题代码：`API_BASE = "https://api.example.com"`

**漏洞描述**：  
API基础URL被硬编码在源代码中。虽然这不是直接的安全风险，但它降低了代码的可维护性和灵活性，可能在需要切换环境时造成问题。

**潜在危害**：
1. 难以在不同环境间切换（开发、测试、生产）
2. 代码部署到不同区域或环境时需要修改源代码
3. 可能导致错误的API调用指向错误的环境

**修复建议**：
```python
import os
from urllib.parse import urljoin

# 从环境变量获取API基础URL
API_BASE = os.environ.get("API_BASE_URL", "https://api.example.com")

def fetch_profile(uid: str):
    url = urljoin(API_BASE, f"v1/users/{uid}")
    r = requests.get(
        url,
        headers={"Authorization": f"Bearer {API_KEY}"}
    )
    return r.json()
```

**安全加固措施**：
1. 使用配置管理系统管理不同环境的配置
2. 实现环境感知的配置加载机制
3. 使用服务发现机制动态获取API端点

**修复后效果**：
1. 提高了代码的可维护性和灵活性
2. 支持不同环境的配置管理
3. 便于进行环境迁移和扩展

## 其他建议

1. **输入验证**
```python
from urllib.parse import urljoin
import re

def fetch_profile(uid: str):
    # 验证uid格式
    if not re.match(r'^[a-zA-Z0-9_-]+$', uid):
        raise ValueError("Invalid user ID format")
    
    url = urljoin(API_BASE, f"v1/users/{uid}")
    r = requests.get(
        url,
        headers={"Authorization": f"Bearer {API_KEY}"}
    )
    
    # 验证响应状态
    r.raise_for_status()
    return r.json()
```

2. **错误处理**
```python
import requests
from requests.exceptions import RequestException
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def fetch_profile(uid: str):
    try:
        r = requests.get(
            urljoin(API_BASE, f"v1/users/{uid}"),
            headers={"Authorization": f"Bearer {API_KEY}"}
        )
        r.raise_for_status()
        return r.json()
    except RequestException as e:
        logger.error(f"Failed to fetch profile for user {uid}: {str(e)}")
        raise
```

3. **超时控制**
```python
def fetch_profile(uid: str):
    try:
        r = requests.get(
            urljoin(API_BASE, f"v1/users/{uid}"),
            headers={"Authorization": f"Bearer {API_KEY}"},
            timeout=(3.05, 27)  # (连接超时, 读取超时)
        )
        r.raise_for_status()
        return r.json()
    except requests.Timeout:
        logger.error(f"Request timed out for user {uid}")
        raise
```

## 结论

代码中存在的主要安全问题是API密钥的硬编码，这是一个高危漏洞，需要立即修复。建议采用环境变量或密钥管理服务来存储和管理敏感凭证。同时，建议实施其他安全最佳实践，如输入验证、错误处理和超时控制，以提高代码的整体安全性和可靠性。

所有提出的修改建议都经过了详细的考虑，并提供了具体的实现方案。修复这些问题将显著提高系统的安全性，并使代码更加符合安全最佳实践。
