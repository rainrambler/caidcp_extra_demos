# 文件上传漏洞安全审计报告

## 1. 路径遍历漏洞 (Path Traversal)

### 漏洞描述
- **漏洞位置**: upload_vuln.py 第21-24行
- **风险等级**: 高
- **CWE编号**: CWE-23: Relative Path Traversal
- **CVSS评分**: 8.6 (高)
  - 攻击向量: 网络
  - 攻击复杂度: 低
  - 所需权限: 无
  - 用户交互: 不需要
  - 影响范围: 系统文件

### 漏洞详情
该应用在处理上传文件时，直接拼接用户提供的文件名到上传目录路径中，未对文件名进行任何过滤或验证：
```python
filename = request.values.get("name") or f.filename
save_path = os.path.join(UPLOAD_DIR, filename)
```

### 潜在危害
1. 攻击者可以通过提供包含`../`的文件名来访问或覆盖上传目录之外的任意文件
2. 可能导致服务器敏感文件泄露或被恶意覆盖
3. 在Windows系统上还可以使用反斜杠`\`进行路径遍历

### 漏洞验证
使用PowerShell脚本(path_trans.ps1)可以轻易实现路径遍历攻击：
```powershell
$Form = @{
  file = $File
  name = "..\..\overwritten.html"  # 逃逸到上级目录
}
```

### 修复建议
1. 对文件名进行安全过滤：
```python
import os
from pathlib import Path

def secure_filename(filename):
    # 移除路径分隔符和空格
    filename = os.path.basename(filename).strip()
    # 仅保留安全字符
    allowed_chars = set("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._")
    filename = ''.join(c for c in filename if c in allowed_chars)
    return filename or 'unnamed_file'

@app.post("/upload")
def upload():
    f = request.files.get("file")
    if not f:
        return "no file", 400
    
    # 安全处理文件名
    filename = secure_filename(request.values.get("name") or f.filename)
    
    # 确保最终路径在目标目录内
    save_path = Path(UPLOAD_DIR) / filename
    if not save_path.resolve().is_relative_to(Path(UPLOAD_DIR).resolve()):
        return "Invalid path", 400
        
    f.save(save_path)
    return f"OK. visit: /uploads/{filename}\n"
```

### 修复后效果
1. 移除了所有路径分隔符，防止目录遍历
2. 仅允许安全的文件名字符
3. 通过Path.resolve()和is_relative_to()双重验证确保文件只能保存在指定目录

## 2. 不安全的文件类型验证 (Unsafe File Type)

### 漏洞描述
- **漏洞位置**: upload_vuln.py 全局
- **风险等级**: 高
- **CWE编号**: CWE-434: Unrestricted Upload of File with Dangerous Type
- **CVSS评分**: 7.5 (高)

### 漏洞详情
应用程序未对上传文件的类型进行任何验证，允许上传任何类型的文件，包括可执行文件和脚本文件。

### 潜在危害
1. 攻击者可以上传恶意JavaScript文件实现XSS攻击
2. 可能上传WebShell获取服务器控制权
3. 可上传HTML文件包含恶意JavaScript代码

### 漏洞验证
poc.html文件演示了通过上传包含JavaScript的HTML文件进行XSS攻击：
```html
<!doctype html><meta charset="utf-8">
<h1>XSS POC</h1><script>alert('XSS from uploaded file');</script>
```

### 修复建议
1. 实现严格的文件类型验证：
```python
import magic  # python-magic库
from werkzeug.utils import secure_filename

ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif', 'pdf', 'txt'}
ALLOWED_MIMES = {
    'image/jpeg', 'image/png', 'image/gif',
    'application/pdf', 'text/plain'
}

def validate_file(file_storage):
    # 检查文件扩展名
    ext = os.path.splitext(file_storage.filename)[1][1:].lower()
    if ext not in ALLOWED_EXTENSIONS:
        return False
        
    # 检查实际文件内容的MIME类型
    file_content = file_storage.read(2048)  # 读取文件头
    file_storage.seek(0)  # 重置文件指针
    mime = magic.from_buffer(file_content, mime=True)
    return mime in ALLOWED_MIMES

@app.post("/upload")
def upload():
    f = request.files.get("file")
    if not f or not validate_file(f):
        return "Invalid file type", 400
    
    # ... 其他代码
```

2. 配置Web服务器不解释上传目录中的文件：
```nginx
# Nginx配置示例
location /uploads {
    add_header Content-Disposition "attachment";
    add_header X-Content-Type-Options "nosniff";
    types { } default_type application/octet-stream;
}
```

### 修复后效果
1. 只允许上传安全的文件类型
2. 通过文件内容验证防止文件类型伪造
3. 即使文件被上传，也不会被浏览器解释执行

## 3. 不安全的文件服务配置 (Unsafe File Serving)

### 漏洞描述
- **漏洞位置**: upload_vuln.py 第27-30行
- **风险等级**: 中
- **CWE编号**: CWE-552: Files or Directories Accessible to External Parties

### 漏洞详情
上传目录被直接暴露为静态资源目录，且未做任何访问控制：
```python
@app.get("/uploads/<path:filename>")
def serve(filename):
    return send_from_directory(UPLOAD_DIR, filename)
```

### 潜在危害
1. 任何人都可以访问上传的文件
2. 可能导致敏感信息泄露
3. 结合XSS等漏洞产生更大危害

### 修复建议
1. 实现访问控制：
```python
from functools import wraps
from flask import session

def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not session.get('user_id'):
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated_function

@app.get("/uploads/<path:filename>")
@login_required
def serve(filename):
    # 验证文件所有权
    if not is_file_owner(filename, session['user_id']):
        abort(403)
    return send_from_directory(UPLOAD_DIR, filename)
```

2. 实现文件访问令牌：
```python
from secrets import token_urlsafe
from time import time

def generate_file_token(filename, expiry=3600):
    token = token_urlsafe(32)
    cache.set(f'file_token:{token}', filename, expiry)
    return token

@app.post("/upload")
def upload():
    # ... 文件上传代码 ...
    token = generate_file_token(filename)
    return {"token": token, "url": f"/download/{token}"}

@app.get("/download/<token>")
def download(token):
    filename = cache.get(f'file_token:{token}')
    if not filename:
        abort(404)
    return send_from_directory(UPLOAD_DIR, filename)
```

### 修复后效果
1. 文件访问需要用户登录
2. 用户只能访问自己上传的文件
3. 文件访问需要临时令牌，无法直接访问

## 总体建议

1. 实现完整的安全控制链：
   - 文件名净化
   - 文件类型验证
   - 文件大小限制
   - 存储路径规范化
   - 访问权限控制
   
2. 增加防御纵深：
   - 使用随机文件名存储
   - 实现文件引用计数
   - 定期清理未引用文件
   - 配置WAF规则
   
3. 完善日志记录：
```python
import logging
logger = logging.getLogger(__name__)

@app.post("/upload")
def upload():
    try:
        # ... 上传代码 ...
        logger.info(f"File uploaded successfully: {filename} by user {session.get('user_id')}")
    except Exception as e:
        logger.error(f"Upload failed: {str(e)}", exc_info=True)
        raise
```

4. 增加监控告警：
   - 监控异常上传模式
   - 监控文件类型分布
   - 监控存储空间使用
   
5. 文档完善：
   - 明确文件上传策略
   - 制定文件保留期限
   - 规范错误处理流程

## 参考资料

1. [OWASP File Upload Cheat Sheet](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)
2. [CWE-434](https://cwe.mitre.org/data/definitions/434.html)
3. [SANS: Securing File Uploads in Web Applications](https://www.sans.org/blog/8-basic-rules-to-implement-secure-file-uploads/)
