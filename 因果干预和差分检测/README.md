# 因果干预与差分检测在代码安全审计中的应用

本项目通过一个Python脚本 `code.py`，演示了两种用于自动化代码安全审计的先进技术：**因果解释（Causal Explanation）** 和 **差分报告（Differential Report）**。这两种方法旨在超越传统的、基于模式匹配的静态分析，提供更深刻、更准确的安全洞见，尤其适用于审计由AI生成的代码。

## 实验目的

本实验旨在证明：
1.  **因果推断的有效性**：通过模拟科学实验中的“干预”操作，我们可以准确定位并**证明**某个特定的代码构造（如 `shell=True`）是导致安全漏洞的直接原因。
2.  **差分检测的精确性**：通过将待审计代码（如AI生成的代码）与一个已知的安全参考实现进行对比，我们可以快速过滤掉通用背景风险，精准识别出由AI引入的、新的、具体的安全问题。

## 脚本 `code.py` 详解

脚本核心包含两个主要功能：

### 1. 因果解释 (`explain_with_causality`)
此函数模拟一种“代码实验”，用于探究漏洞的根本原因。
- **检测**：首先，它会寻找代码中已知的危险API调用（如 `subprocess.run`）以及高风险参数（如 `shell=True`）。
- **干预 (Do-Operation)**：如果发现风险，它会执行一次“因果干预”，在抽象语法树（AST）层面强行将 `shell=True` 修改为 `shell=False`，生成一个“修复后”的虚拟代码版本。
- **验证**：最后，它会重新分析“修复后”的代码。如果漏洞警告消失，就得出结论：`shell=True` 参数是导致该漏洞的**核心原因**。

### 2. 差分报告 (`differential_report`)
此函数用于比较两段功能相似但安全水平不同的代码（例如，AI生成的代码 vs. 人类专家的安全代码）。
- **独立分析**：分别扫描两段代码，列出各自包含的风险操作。
- **风险对比**：找出只在AI代码中存在，而在安全参考代码中不存在的风险点。
- **代码差异**：生成一份直观的 `diff` 报告，清晰地展示两段代码在实现上的关键安全差异。

## 如何运行

直接在终端中执行Python脚本即可：
```shell
python code.py
```

## 输出结果分析

执行脚本后，会得到以下输出：

```
==因果解释==
{'vulnerable': False, 'reason': 'no user-controlled shell=True'}
==差分报告==
AI 风险调用: [{'api': ('subprocess', 'run'), 'shell_true': True, 'arg_src': 'cmd'}]
参考实现风险调用: []
--- secure_ref.py
+++ ai_code.py
@@ -1,4 +1,4 @@

-import subprocess, sys, shlex
-cmd = sys.argv[1]
-subprocess.run(["/usr/bin/ls", "--", cmd])    # 参数列表，不走 shell
+import subprocess, sys
+cmd = sys.argv[1]                       # 模拟用户输入
+subprocess.run(cmd, shell=True)         # 可注入
```

### 对输出的解读

#### 关于“因果解释”
- **结论**：`'vulnerable': False`，即“未发现漏洞”。
- **原因分析**：这个结论实际上是**错误的**，但它暴露了当前脚本中污点分析（Taint Analysis）的局限性。脚本中的 `uses_user_input` 函数通过简单的字符串匹配来判断数据来源，它检查了 `subprocess.run` 的参数 `cmd`，但未能向上追溯到 `cmd` 变量实际上来源于用户输入 `sys.argv[1]`。因此，它错误地认为不存在“由用户控制的 `shell=True` 调用”。这恰好说明了实现精确的污点追踪是复杂但至关重要的。

#### 关于“差分报告”
- **结论**：成功识别出风险。
- **原因分析**：
    - **AI 风险调用**：报告在AI代码中发现了一个高风险操作，即 `subprocess.run` 配合 `shell_true: True`。
    - **参考实现风险调用**：在安全参考代码中未发现风险。
    - **代码差异**：`diff` 结果一目了然地指出了两者的核心区别：AI代码将用户输入拼接到一个字符串中并使用 `shell=True` 执行，而安全代码则使用了更安全的参数列表形式，从根本上避免了命令注入。

## 结论

本实验成功展示了：
- **因果解释**在精确定位漏洞成因方面的巨大潜力，但其准确性高度依赖于底层分析技术（如污点追踪）的完备性。
- **差分报告**作为一种轻量级但高效的审计方法，能够快速聚焦于AI代码引入的增量风险，非常适合用于AI辅助编程场景下的安全评估。
